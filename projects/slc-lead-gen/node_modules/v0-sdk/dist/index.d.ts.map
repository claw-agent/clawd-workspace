{"version":3,"file":"index.d.ts","sources":["../src/sdk/core.ts","../src/sdk/v0.ts"],"sourcesContent":["export interface ClientConfig {\n  apiKey?: string\n  baseUrl?: string\n}\n\nexport function createFetcher(config: ClientConfig = {}) {\n  const baseUrl = config.baseUrl || 'https://api.v0.dev/v1'\n  let sessionToken: string | null = null\n\n  return async function fetcher(\n    url: string,\n    method: string,\n    params: {\n      body?: any\n      query?: Record<string, string>\n      pathParams?: Record<string, string>\n      headers?: Record<string, string>\n    } = {},\n  ): Promise<any> {\n    const apiKey = config.apiKey || process.env.V0_API_KEY\n\n    if (!apiKey) {\n      throw new Error(\n        'API key is required. Provide it via config.apiKey or V0_API_KEY environment variable',\n      )\n    }\n\n    const queryString = params.query\n      ? '?' + new URLSearchParams(params.query).toString()\n      : ''\n\n    const finalUrl = baseUrl + url + queryString\n\n    const hasBody = method !== 'GET' && params.body\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${apiKey}`,\n      'User-Agent': 'v0-sdk/0.1.0',\n      ...params.headers,\n    }\n\n    // Include session token in headers if available\n    if (sessionToken) {\n      headers['x-session-token'] = sessionToken\n    }\n\n    if (hasBody) {\n      headers['Content-Type'] = 'application/json'\n    }\n\n    const res = await fetch(finalUrl, {\n      method,\n      headers,\n      body: hasBody ? JSON.stringify(params.body) : undefined,\n    })\n\n    // Check for session token in response headers\n    const newSessionToken = res.headers.get('x-session-token')\n    if (newSessionToken) {\n      sessionToken = newSessionToken\n    }\n\n    if (!res.ok) {\n      const text = await res.text()\n      throw new Error(`HTTP ${res.status}: ${text}`)\n    }\n\n    // Handle binary responses based on Content-Type\n    const contentType = res.headers.get('content-type') || ''\n    if (\n      contentType.includes('application/zip') ||\n      contentType.includes('application/gzip')\n    ) {\n      return res.arrayBuffer()\n    }\n\n    return res.json()\n  }\n}\n\n// Streaming response types\nexport interface StreamEvent {\n  event?: string\n  data: string\n}\n\n// Utility function to parse streaming events\nexport async function* parseStreamingResponse(\n  stream: ReadableStream<Uint8Array>,\n): AsyncGenerator<StreamEvent, void, unknown> {\n  const reader = stream.getReader()\n  const decoder = new TextDecoder()\n  let buffer = ''\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) break\n\n      buffer += decoder.decode(value, { stream: true })\n      const lines = buffer.split('\\n')\n      buffer = lines.pop() || '' // Keep the last incomplete line in buffer\n\n      for (const line of lines) {\n        if (line.trim() === '') continue\n\n        if (line.startsWith('data: ')) {\n          const data = line.slice(6)\n          if (data === '[DONE]') return\n\n          try {\n            yield {\n              event: 'message',\n              data: data,\n            }\n          } catch (e) {\n            console.warn('Failed to parse streaming data:', e)\n          }\n        } else if (line.startsWith('event: ')) {\n          const event = line.slice(7)\n          yield {\n            event: event,\n            data: '',\n          }\n        }\n      }\n    }\n  } finally {\n    reader.releaseLock()\n  }\n}\n\nexport function createStreamingFetcher(config: ClientConfig = {}) {\n  const baseUrl = config.baseUrl || 'https://api.v0.dev/v1'\n  let sessionToken: string | null = null\n\n  return async function streamingFetcher(\n    url: string,\n    method: string,\n    params: {\n      body?: any\n      query?: Record<string, string>\n      pathParams?: Record<string, string>\n      headers?: Record<string, string>\n    } = {},\n  ): Promise<ReadableStream<Uint8Array>> {\n    const apiKey = config.apiKey || process.env.V0_API_KEY\n\n    if (!apiKey) {\n      throw new Error(\n        'API key is required. Provide it via config.apiKey or V0_API_KEY environment variable',\n      )\n    }\n\n    const queryString = params.query\n      ? '?' + new URLSearchParams(params.query).toString()\n      : ''\n\n    const finalUrl = baseUrl + url + queryString\n\n    const hasBody = method !== 'GET' && params.body\n    const headers: Record<string, string> = {\n      Authorization: `Bearer ${apiKey}`,\n      'User-Agent': 'v0-sdk/0.1.0',\n      Accept: 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      ...params.headers,\n    }\n\n    // Include session token in headers if available\n    if (sessionToken) {\n      headers['x-session-token'] = sessionToken\n    }\n\n    if (hasBody) {\n      headers['Content-Type'] = 'application/json'\n    }\n\n    const res = await fetch(finalUrl, {\n      method,\n      headers,\n      body: hasBody ? JSON.stringify(params.body) : undefined,\n    })\n\n    // Check for session token in response headers\n    const newSessionToken = res.headers.get('x-session-token')\n    if (newSessionToken) {\n      sessionToken = newSessionToken\n    }\n\n    if (!res.ok) {\n      const text = await res.text()\n      throw new Error(`HTTP ${res.status}: ${text}`)\n    }\n\n    if (!res.body) {\n      throw new Error('No response body available for streaming')\n    }\n\n    return res.body\n  }\n}\n","import { createFetcher, createStreamingFetcher } from './core'\n\n// Re-export streaming utilities from core\nexport { parseStreamingResponse, type StreamEvent } from './core'\n\nexport type ChatDetail = {\n  id: string\n  object: 'chat'\n  shareable: boolean\n  privacy: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted'\n  name?: string\n  /** @deprecated */\n  title?: string\n  createdAt: string\n  updatedAt?: string\n  favorite: boolean\n  authorId: string\n  projectId?: string\n  webUrl: string\n  apiUrl: string\n  latestVersion?: {\n    id: string\n    object: 'version'\n    status: 'pending' | 'completed' | 'failed'\n    demoUrl?: string\n    screenshotUrl?: string\n    createdAt: string\n    updatedAt?: string\n    files: {\n      object: 'file'\n      name: string\n      content: string\n      locked: boolean\n    }[]\n  }\n  /** @deprecated */\n  url: string\n  messages: Array<{\n    id: string\n    object: 'message'\n    content: string\n    experimental_content?: Array<unknown[] | unknown[]>\n    createdAt: string\n    updatedAt?: string\n    type:\n      | 'message'\n      | 'forked-block'\n      | 'forked-chat'\n      | 'open-in-v0'\n      | 'refinement'\n      | 'added-environment-variables'\n      | 'added-integration'\n      | 'deleted-file'\n      | 'moved-file'\n      | 'renamed-file'\n      | 'edited-file'\n      | 'replace-src'\n      | 'reverted-block'\n      | 'fix-with-v0'\n      | 'auto-fix-with-v0'\n      | 'sync-git'\n      | 'pull-changes'\n      | 'fix-cve'\n      | 'answered-questions'\n    role: 'user' | 'assistant'\n    finishReason?:\n      | 'stop'\n      | 'length'\n      | 'content-filter'\n      | 'tool-calls'\n      | 'error'\n      | 'other'\n      | 'unknown'\n    apiUrl: string\n    authorId: string | null\n    parentId?: string | null\n    attachments?: Array<{\n      url: string\n      name?: string\n      contentType?: string\n      size: number\n      content?: string\n      type?: 'screenshot' | 'figma' | 'zip'\n    }>\n  }>\n  files?: {\n    lang: string\n    meta: Record<string, unknown>\n    source: string\n  }[]\n  /** @deprecated */\n  demo?: string\n  text: string\n  modelConfiguration?: {\n    /** @deprecated */\n    modelId?: 'v0-mini' | 'v0-pro' | 'v0-max'\n    imageGenerations?: boolean\n    thinking?: boolean\n  }\n  permissions: {\n    write: boolean\n  }\n}\n\nexport type ChatSummary = {\n  id: string\n  object: 'chat'\n  shareable: boolean\n  privacy: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted'\n  name?: string\n  /** @deprecated */\n  title?: string\n  createdAt: string\n  updatedAt?: string\n  favorite: boolean\n  authorId: string\n  projectId?: string\n  webUrl: string\n  apiUrl: string\n  latestVersion?: {\n    id: string\n    object: 'version'\n    status: 'pending' | 'completed' | 'failed'\n    demoUrl?: string\n    screenshotUrl?: string\n    createdAt: string\n    updatedAt?: string\n  }\n}\n\nexport interface DeploymentDetail {\n  id: string\n  object: 'deployment'\n  inspectorUrl: string\n  chatId: string\n  projectId: string\n  versionId: string\n  apiUrl: string\n  webUrl: string\n}\n\nexport interface DeploymentSummary {\n  id: string\n  object: 'deployment'\n  inspectorUrl: string\n  chatId: string\n  projectId: string\n  versionId: string\n  apiUrl: string\n  webUrl: string\n}\n\nexport interface EnvironmentVariableDetailSchema {\n  id: string\n  object: 'environment_variable'\n  key: string\n  value: string\n  decrypted: boolean\n  createdAt: number\n  updatedAt?: number\n}\n\nexport interface EnvironmentVariableSummarySchema {\n  id: string\n  object: 'environment_variable'\n  key: string\n  value: string\n  decrypted: boolean\n  createdAt: number\n  updatedAt?: number\n}\n\nexport interface EnvironmentVariablesListSchema {\n  object: 'list'\n  data: {\n    id: string\n    object: 'environment_variable'\n    key: string\n    value: string\n    decrypted: boolean\n    createdAt: number\n    updatedAt?: number\n  }[]\n}\n\nexport interface FileDetail {\n  object: 'file'\n  name: string\n  content: string\n  locked: boolean\n}\n\nexport interface FileSummary {\n  object: 'file'\n  name: string\n}\n\nexport type HookDetail = {\n  id: string\n  object: 'hook'\n  name: string\n  events: Array<\n    | 'chat.created'\n    | 'chat.updated'\n    | 'chat.deleted'\n    | 'message.created'\n    | 'message.updated'\n    | 'message.deleted'\n    | 'message.finished'\n  >\n  chatId?: string\n  url: string\n}\n\nexport type HookEventDetail = {\n  id: string\n  object: 'hook_event'\n  event:\n    | 'chat.created'\n    | 'chat.updated'\n    | 'chat.deleted'\n    | 'message.created'\n    | 'message.updated'\n    | 'message.deleted'\n    | 'message.finished'\n  status?: 'pending' | 'success' | 'error'\n  createdAt: string\n}\n\nexport interface HookSummary {\n  id: string\n  object: 'hook'\n  name: string\n}\n\nexport interface IntegrationConnectionDetailSchema {\n  object: 'integration_connection'\n  id: string\n  connected: boolean\n  integration: {\n    id: string\n    object: 'integration'\n    slug: string\n    name: string\n  }\n  metadata?: Record<string, unknown>\n}\n\nexport interface IntegrationConnectionListSchema {\n  object: 'list'\n  data: {\n    object: 'integration_connection'\n    id: string\n    connected: boolean\n    integration: {\n      id: string\n      object: 'integration'\n      slug: string\n      name: string\n    }\n  }[]\n}\n\nexport interface IntegrationConnectionSummarySchema {\n  object: 'integration_connection'\n  id: string\n  connected: boolean\n  integration: {\n    id: string\n    object: 'integration'\n    slug: string\n    name: string\n  }\n}\n\nexport interface IntegrationDetailSchema {\n  id: string\n  object: 'integration'\n  slug: string\n  name: string\n  description: string\n  iconUrl: string\n}\n\nexport interface IntegrationListSchema {\n  object: 'list'\n  data: {\n    id: string\n    object: 'integration'\n    slug: string\n    name: string\n    description: string\n    iconUrl: string\n  }[]\n}\n\nexport interface IntegrationSummarySchema {\n  id: string\n  object: 'integration'\n  slug: string\n  name: string\n}\n\nexport type MessageDetail = {\n  id: string\n  object: 'message'\n  content: string\n  experimental_content?: Array<unknown[] | unknown[]>\n  createdAt: string\n  updatedAt?: string\n  type:\n    | 'message'\n    | 'forked-block'\n    | 'forked-chat'\n    | 'open-in-v0'\n    | 'refinement'\n    | 'added-environment-variables'\n    | 'added-integration'\n    | 'deleted-file'\n    | 'moved-file'\n    | 'renamed-file'\n    | 'edited-file'\n    | 'replace-src'\n    | 'reverted-block'\n    | 'fix-with-v0'\n    | 'auto-fix-with-v0'\n    | 'sync-git'\n    | 'pull-changes'\n    | 'fix-cve'\n    | 'answered-questions'\n  role: 'user' | 'assistant'\n  finishReason?:\n    | 'stop'\n    | 'length'\n    | 'content-filter'\n    | 'tool-calls'\n    | 'error'\n    | 'other'\n    | 'unknown'\n  apiUrl: string\n  authorId: string | null\n  parentId?: string | null\n  attachments?: Array<{\n    url: string\n    name?: string\n    contentType?: string\n    size: number\n    content?: string\n    type?: 'screenshot' | 'figma' | 'zip'\n  }>\n  chatId: string\n}\n\nexport type MessageSummary = {\n  id: string\n  object: 'message'\n  content: string\n  experimental_content?: Array<unknown[] | unknown[]>\n  createdAt: string\n  updatedAt?: string\n  type:\n    | 'message'\n    | 'forked-block'\n    | 'forked-chat'\n    | 'open-in-v0'\n    | 'refinement'\n    | 'added-environment-variables'\n    | 'added-integration'\n    | 'deleted-file'\n    | 'moved-file'\n    | 'renamed-file'\n    | 'edited-file'\n    | 'replace-src'\n    | 'reverted-block'\n    | 'fix-with-v0'\n    | 'auto-fix-with-v0'\n    | 'sync-git'\n    | 'pull-changes'\n    | 'fix-cve'\n    | 'answered-questions'\n  role: 'user' | 'assistant'\n  finishReason?:\n    | 'stop'\n    | 'length'\n    | 'content-filter'\n    | 'tool-calls'\n    | 'error'\n    | 'other'\n    | 'unknown'\n  apiUrl: string\n  authorId: string | null\n  parentId?: string | null\n  attachments?: Array<{\n    url: string\n    name?: string\n    contentType?: string\n    size: number\n    content?: string\n    type?: 'screenshot' | 'figma' | 'zip'\n  }>\n}\n\nexport type MessageSummaryList = {\n  object: 'list'\n  data: Array<{\n    id: string\n    object: 'message'\n    content: string\n    experimental_content?: Array<unknown[] | unknown[]>\n    createdAt: string\n    updatedAt?: string\n    type:\n      | 'message'\n      | 'forked-block'\n      | 'forked-chat'\n      | 'open-in-v0'\n      | 'refinement'\n      | 'added-environment-variables'\n      | 'added-integration'\n      | 'deleted-file'\n      | 'moved-file'\n      | 'renamed-file'\n      | 'edited-file'\n      | 'replace-src'\n      | 'reverted-block'\n      | 'fix-with-v0'\n      | 'auto-fix-with-v0'\n      | 'sync-git'\n      | 'pull-changes'\n      | 'fix-cve'\n      | 'answered-questions'\n    role: 'user' | 'assistant'\n    finishReason?:\n      | 'stop'\n      | 'length'\n      | 'content-filter'\n      | 'tool-calls'\n      | 'error'\n      | 'other'\n      | 'unknown'\n    apiUrl: string\n    authorId: string | null\n    parentId?: string | null\n    attachments?: Array<{\n      url: string\n      name?: string\n      contentType?: string\n      size: number\n      content?: string\n      type?: 'screenshot' | 'figma' | 'zip'\n    }>\n  }>\n  pagination: {\n    hasMore: boolean\n    nextCursor?: string\n    nextUrl?: string\n  }\n}\n\nexport interface NotificationPreferenceSchema {\n  liveActivity: boolean\n  pushNotifications: boolean\n}\n\nexport interface ProductDetailSchema {\n  object: 'product'\n  id: string\n  slug: string\n  name: string\n  description: string\n  iconUrl: string\n  iconBackgroundColor?: string\n}\n\nexport interface ProductListSchema {\n  object: 'list'\n  data: {\n    object: 'product'\n    id: string\n    slug: string\n    name: string\n    description: string\n    iconUrl: string\n  }[]\n}\n\nexport interface ProductSummarySchema {\n  object: 'product'\n  id: string\n  slug: string\n  name: string\n  description: string\n  iconUrl: string\n}\n\nexport type ProjectDetail = {\n  id: string\n  object: 'project'\n  name: string\n  privacy: 'private' | 'team'\n  vercelProjectId?: string\n  createdAt: string\n  updatedAt?: string\n  apiUrl: string\n  webUrl: string\n  description?: string\n  instructions?: string\n  chats: Array<{\n    id: string\n    object: 'chat'\n    shareable: boolean\n    privacy: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted'\n    name?: string\n    /** @deprecated */\n    title?: string\n    createdAt: string\n    updatedAt?: string\n    favorite: boolean\n    authorId: string\n    projectId?: string\n    webUrl: string\n    apiUrl: string\n    latestVersion?: {\n      id: string\n      object: 'version'\n      status: 'pending' | 'completed' | 'failed'\n      demoUrl?: string\n      screenshotUrl?: string\n      createdAt: string\n      updatedAt?: string\n    }\n  }>\n}\n\nexport type ProjectSummary = {\n  id: string\n  object: 'project'\n  name: string\n  privacy: 'private' | 'team'\n  vercelProjectId?: string\n  createdAt: string\n  updatedAt?: string\n  apiUrl: string\n  webUrl: string\n}\n\nexport interface ScopeSummary {\n  id: string\n  object: 'scope'\n  name?: string\n}\n\nexport type SearchResultItem = {\n  id: string\n  object: 'chat' | 'project'\n  name: string\n  createdAt: string\n  updatedAt?: string\n  apiUrl: string\n  webUrl: string\n}\n\nexport interface UserDetailSchema {\n  id: string\n  object: 'user'\n  name?: string\n  email: string\n  avatar: string\n  createdAt: string\n  updatedAt?: string\n}\n\nexport type UserPreferencesPostResponseSchema = {\n  object: 'user_preferences'\n  preferences:\n    | {\n        notifications: {\n          liveActivity: boolean\n          pushNotifications: boolean\n        }\n      }\n    | unknown\n}\n\nexport type UserPreferencesResponseSchema = {\n  object: 'user_preferences'\n  preferences:\n    | {\n        notifications: {\n          liveActivity: boolean\n          pushNotifications: boolean\n        }\n      }\n    | unknown\n}\n\nexport interface UserPreferencesSchema {\n  notifications: {\n    liveActivity: boolean\n    pushNotifications: boolean\n  }\n}\n\nexport interface UserSummarySchema {\n  id: string\n  object: 'user'\n  name?: string\n  email: string\n  avatar: string\n  createdAt: string\n  updatedAt?: string\n}\n\nexport interface VercelProjectDetail {\n  id: string\n  object: 'vercel_project'\n  name: string\n}\n\nexport interface VercelProjectSummary {\n  id: string\n  object: 'vercel_project'\n  name: string\n}\n\nexport type VersionDetail = {\n  id: string\n  object: 'version'\n  status: 'pending' | 'completed' | 'failed'\n  demoUrl?: string\n  screenshotUrl?: string\n  createdAt: string\n  updatedAt?: string\n  files: {\n    object: 'file'\n    name: string\n    content: string\n    locked: boolean\n  }[]\n}\n\nexport type VersionSummary = {\n  id: string\n  object: 'version'\n  status: 'pending' | 'completed' | 'failed'\n  demoUrl?: string\n  screenshotUrl?: string\n  createdAt: string\n  updatedAt?: string\n}\n\nexport type VersionSummaryList = {\n  object: 'list'\n  data: Array<{\n    id: string\n    object: 'version'\n    status: 'pending' | 'completed' | 'failed'\n    demoUrl?: string\n    screenshotUrl?: string\n    createdAt: string\n    updatedAt?: string\n  }>\n  pagination: {\n    hasMore: boolean\n    nextCursor?: string\n    nextUrl?: string\n  }\n}\n\nexport interface UnauthorizedError {\n  error: {\n    message: string\n    type: 'unauthorized_error'\n  }\n}\n\nexport interface ForbiddenError {\n  error: {\n    message: string\n    type: 'forbidden_error'\n  }\n}\n\nexport interface NotFoundError {\n  error: {\n    message: string\n    type: 'not_found_error'\n  }\n}\n\nexport interface ConflictError {\n  error: {\n    message: string\n    type: 'conflict_error'\n  }\n}\n\nexport interface PayloadTooLargeError {\n  error: {\n    message: string\n    type: 'payload_too_large_error'\n  }\n}\n\nexport interface UnprocessableEntityError {\n  error: {\n    message: string\n    type: 'unprocessable_entity_error'\n  }\n}\n\nexport interface TooManyRequestsError {\n  error: {\n    message: string\n    type: 'too_many_requests_error'\n  }\n}\n\nexport interface InternalServerError {\n  error: {\n    message: string\n    type: 'internal_server_error'\n  }\n}\n\nexport interface ChatsCreateRequest {\n  message: string\n  attachments?: {\n    url: string\n  }[]\n  system?: string\n  chatPrivacy?: 'public' | 'private' | 'team-edit' | 'team' | 'unlisted'\n  projectId?: string\n  modelConfiguration?: {\n    /** @deprecated */\n    modelId?: 'v0-mini' | 'v0-pro' | 'v0-max'\n    imageGenerations?: boolean\n    thinking?: boolean\n  }\n  responseMode?: 'sync' | 'async' | 'experimental_stream'\n  designSystemId?: string | null\n}\n\nexport type ChatsCreateResponse = ChatDetail\n\nexport type ChatsCreateStreamResponse = ReadableStream<Uint8Array>\n\nexport interface ChatsFindResponse {\n  object: 'list'\n  data: ChatSummary[]\n}\n\nexport type ChatsInitRequest = {\n  name?: string\n  chatPrivacy?: 'public' | 'private' | 'team-edit' | 'team' | 'unlisted'\n  projectId?: string\n} & (\n  | {\n      type: 'files'\n      files: Array<\n        | {\n            name: string\n            url: string\n            locked?: boolean\n            content?: never\n          }\n        | {\n            name: string\n            content: string\n            locked?: boolean\n            url?: never\n          }\n      >\n      repo?: never\n      lockAllFiles?: never\n      registry?: never\n      zip?: never\n      templateId?: never\n    }\n  | {\n      type: 'repo'\n      repo: {\n        url: string\n        branch?: string\n      }\n      lockAllFiles?: boolean\n      files?: never\n      registry?: never\n      zip?: never\n      templateId?: never\n    }\n  | {\n      type: 'registry'\n      registry: {\n        url: string\n      }\n      lockAllFiles?: boolean\n      files?: never\n      repo?: never\n      zip?: never\n      templateId?: never\n    }\n  | {\n      type: 'zip'\n      zip: {\n        url: string\n      }\n      lockAllFiles?: boolean\n      files?: never\n      repo?: never\n      registry?: never\n      templateId?: never\n    }\n  | {\n      type: 'template'\n      templateId: string\n      files?: never\n      repo?: never\n      lockAllFiles?: never\n      registry?: never\n      zip?: never\n    }\n)\n\nexport type ChatsInitResponse = ChatDetail\n\nexport interface ChatsDeleteResponse {\n  id: string\n  object: 'chat'\n  deleted: true\n}\n\nexport type ChatsGetByIdResponse = ChatDetail\n\nexport interface ChatsUpdateRequest {\n  name?: string\n  privacy?: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted'\n}\n\nexport type ChatsUpdateResponse = ChatDetail\n\nexport interface ChatsFavoriteRequest {\n  isFavorite: boolean\n}\n\nexport interface ChatsFavoriteResponse {\n  id: string\n  object: 'chat'\n  favorited: boolean\n}\n\nexport interface ChatsForkRequest {\n  versionId?: string\n  privacy?: 'public' | 'private' | 'team' | 'team-edit' | 'unlisted'\n}\n\nexport type ChatsForkResponse = ChatDetail\n\nexport type ProjectsGetByChatIdResponse = ProjectDetail\n\nexport interface ChatsFindMessagesResponse {\n  object: 'list'\n  data: MessageSummary[]\n  pagination: {\n    hasMore: boolean\n    nextCursor?: string\n    nextUrl?: string\n  }\n}\n\nexport interface ChatsSendMessageRequest {\n  message: string\n  attachments?: {\n    url: string\n  }[]\n  system?: string\n  modelConfiguration?: {\n    /** @deprecated */\n    modelId?: 'v0-mini' | 'v0-pro' | 'v0-max'\n    imageGenerations?: boolean\n    thinking?: boolean\n  }\n  responseMode?: 'sync' | 'async' | 'experimental_stream'\n}\n\nexport type ChatsSendMessageResponse = ChatDetail\n\nexport type ChatsSendMessageStreamResponse = ReadableStream<Uint8Array>\n\nexport type ChatsGetMessageResponse = MessageDetail\n\nexport interface ChatsFindVersionsResponse {\n  object: 'list'\n  data: VersionSummary[]\n  pagination: {\n    hasMore: boolean\n    nextCursor?: string\n    nextUrl?: string\n  }\n}\n\nexport type ChatsGetVersionResponse = VersionDetail\n\nexport interface ChatsUpdateVersionRequest {\n  files: {\n    name: string\n    content: string\n    locked?: boolean\n  }[]\n}\n\nexport type ChatsUpdateVersionResponse = VersionDetail\n\nexport type ChatsResumeResponse = MessageDetail\n\nexport interface DeploymentsFindResponse {\n  object: 'list'\n  data: DeploymentDetail[]\n}\n\nexport interface DeploymentsCreateRequest {\n  projectId: string\n  chatId: string\n  versionId: string\n}\n\nexport type DeploymentsCreateResponse = DeploymentDetail\n\nexport type DeploymentsGetByIdResponse = DeploymentDetail\n\nexport interface DeploymentsDeleteResponse {\n  id: string\n  object: 'deployment'\n  deleted: true\n}\n\nexport type DeploymentsFindLogsResponse = {\n  logs: Array<{\n    createdAt: string\n    deploymentId: string\n    id: string\n    text: string\n    type: 'stdout' | 'stderr'\n    level?: 'error' | 'warning' | 'info'\n    object: 'deployment_log'\n  }>\n  nextSince?: number\n  object: 'list'\n}\n\nexport interface DeploymentsFindErrorsResponse {\n  error?: string\n  fullErrorText?: string\n  errorType?: string\n  formattedError?: string\n}\n\nexport interface HooksFindResponse {\n  object: 'list'\n  data: HookSummary[]\n}\n\nexport interface HooksCreateRequest {\n  name: string\n  events: Array<\n    | 'chat.created'\n    | 'chat.updated'\n    | 'chat.deleted'\n    | 'message.created'\n    | 'message.updated'\n    | 'message.deleted'\n    | 'message.finished'\n  >\n  chatId?: string\n  url: string\n}\n\nexport type HooksCreateResponse = HookDetail\n\nexport type HooksGetByIdResponse = HookDetail\n\nexport interface HooksUpdateRequest {\n  name?: string\n  events?: Array<\n    | 'chat.created'\n    | 'chat.updated'\n    | 'chat.deleted'\n    | 'message.created'\n    | 'message.updated'\n    | 'message.deleted'\n    | 'message.finished'\n  >\n  url?: string\n}\n\nexport type HooksUpdateResponse = HookDetail\n\nexport interface HooksDeleteResponse {\n  id: string\n  object: 'hook'\n  deleted: true\n}\n\nexport interface IntegrationsVercelProjectsFindResponse {\n  object: 'list'\n  data: VercelProjectSummary[]\n}\n\nexport interface IntegrationsVercelProjectsCreateRequest {\n  projectId: string\n  name: string\n}\n\nexport type IntegrationsVercelProjectsCreateResponse = VercelProjectDetail\n\nexport interface ProjectsFindResponse {\n  object: 'list'\n  data: ProjectSummary[]\n}\n\nexport interface ProjectsCreateRequest {\n  name: string\n  description?: string\n  icon?: string\n  environmentVariables?: {\n    key: string\n    value: string\n  }[]\n  instructions?: string\n  vercelProjectId?: string\n  privacy?: 'private' | 'team'\n}\n\nexport type ProjectsCreateResponse = ProjectDetail\n\nexport type ProjectsGetByIdResponse = ProjectDetail\n\nexport interface ProjectsUpdateRequest {\n  name?: string\n  description?: string\n  instructions?: string\n  privacy?: 'private' | 'team'\n}\n\nexport type ProjectsUpdateResponse = ProjectDetail\n\nexport interface ProjectsDeleteResponse {\n  id: string\n  object: 'project'\n  deleted: true\n}\n\nexport interface ProjectsAssignRequest {\n  chatId: string\n}\n\nexport interface ProjectsAssignResponse {\n  object: 'project'\n  id: string\n  assigned: true\n}\n\nexport interface ProjectsFindEnvVarsResponse {\n  object: 'list'\n  data: EnvironmentVariableSummarySchema[]\n}\n\nexport interface ProjectsCreateEnvVarsRequest {\n  environmentVariables: {\n    key: string\n    value: string\n  }[]\n  upsert?: boolean\n}\n\nexport interface ProjectsCreateEnvVarsResponse {\n  object: 'list'\n  data: EnvironmentVariableSummarySchema[]\n}\n\nexport interface ProjectsUpdateEnvVarsRequest {\n  environmentVariables: {\n    id: string\n    value: string\n  }[]\n}\n\nexport interface ProjectsUpdateEnvVarsResponse {\n  object: 'list'\n  data: EnvironmentVariableSummarySchema[]\n}\n\nexport interface ProjectsDeleteEnvVarsRequest {\n  environmentVariableIds: string[]\n}\n\nexport interface ProjectsDeleteEnvVarsResponse {\n  object: 'list'\n  data: {\n    id: string\n    object: 'environment_variable'\n    deleted: true\n  }[]\n}\n\nexport interface ProjectsGetEnvVarResponse {\n  object: 'environment_variable'\n  data: EnvironmentVariableDetailSchema\n}\n\nexport interface RateLimitsFindResponse {\n  remaining?: number\n  reset?: number\n  limit: number\n  dailyLimit?: {\n    limit: number\n    remaining: number\n    reset: number\n    isWithinGracePeriod: boolean\n  }\n}\n\nexport type UserGetResponse = UserSummarySchema\n\nexport type UserGetBillingResponse =\n  | {\n      billingType: 'token'\n      data: {\n        plan: string\n        billingMode?: 'test'\n        role: string\n        billingCycle: {\n          start: number\n          end: number\n        }\n        balance: {\n          remaining: number\n          total: number\n        }\n        onDemand: {\n          balance: number\n          blocks?: {\n            expirationDate?: number\n            effectiveDate: number\n            originalBalance: number\n            currentBalance: number\n          }[]\n        }\n      }\n    }\n  | {\n      billingType: 'legacy'\n      data: {\n        remaining?: number\n        reset?: number\n        limit: number\n      }\n    }\n\nexport interface UserGetPlanResponse {\n  object: 'plan'\n  plan: string\n  billingCycle: {\n    start: number\n    end: number\n  }\n  balance: {\n    remaining: number\n    total: number\n  }\n}\n\nexport interface UserGetScopesResponse {\n  object: 'list'\n  data: ScopeSummary[]\n}\n\nexport type ReportsGetUsageResponse = {\n  object: 'list'\n  data: Array<{\n    id: string\n    object: 'usage_event'\n    type?:\n      | 'image_generation'\n      | 'message'\n      | 'manual_debit'\n      | 'api_request'\n      | 'inline-edit'\n      | 'buy-template'\n      | 'reverse_template_sale'\n      | 'refund_template_purchase'\n    promptCost?: string\n    completionCost?: string\n    totalCost: string\n    chatId?: string\n    messageId?: string\n    userId?: string\n    user?: UserSummarySchema\n    createdAt: string\n  }>\n  pagination: {\n    hasMore: boolean\n    nextCursor?: string\n    nextUrl?: string\n  }\n  meta: {\n    totalCount: number\n  }\n}\n\nexport interface V0ClientConfig {\n  apiKey?: string\n  baseUrl?: string\n}\n\nexport function createClient(config: V0ClientConfig = {}) {\n  const fetcher = createFetcher(config)\n  const streamingFetcher = createStreamingFetcher(config)\n\n  return {\n    chats: {\n      async create(\n        params: ChatsCreateRequest,\n      ): Promise<ChatsCreateResponse | ChatsCreateStreamResponse> {\n        const body = {\n          message: params.message,\n          attachments: params.attachments,\n          system: params.system,\n          chatPrivacy: params.chatPrivacy,\n          projectId: params.projectId,\n          modelConfiguration: params.modelConfiguration,\n          responseMode: params.responseMode,\n          designSystemId: params.designSystemId,\n        }\n\n        if (params.responseMode === 'experimental_stream') {\n          return await streamingFetcher(`/chats`, 'POST', { body })\n        }\n\n        return fetcher(`/chats`, 'POST', { body })\n      },\n\n      async find(params?: {\n        limit?: number\n        offset?: number\n        isFavorite?: boolean\n      }): Promise<ChatsFindResponse> {\n        const query = params\n          ? (Object.fromEntries(\n              Object.entries({\n                limit:\n                  params.limit !== undefined ? String(params.limit) : undefined,\n                offset:\n                  params.offset !== undefined\n                    ? String(params.offset)\n                    : undefined,\n                isFavorite:\n                  params.isFavorite !== undefined\n                    ? String(params.isFavorite)\n                    : undefined,\n              }).filter(([_, value]) => value !== undefined),\n            ) as Record<string, string>)\n          : {}\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/chats`, 'GET', { ...(hasQuery ? { query } : {}) })\n      },\n\n      async init(params: ChatsInitRequest): Promise<ChatsInitResponse> {\n        const body = params\n        return fetcher(`/chats/init`, 'POST', { body })\n      },\n\n      async delete(params: { chatId: string }): Promise<ChatsDeleteResponse> {\n        const pathParams = { chatId: params.chatId }\n        return fetcher(`/chats/${pathParams.chatId}`, 'DELETE', { pathParams })\n      },\n\n      async getById(params: { chatId: string }): Promise<ChatsGetByIdResponse> {\n        const pathParams = { chatId: params.chatId }\n        return fetcher(`/chats/${pathParams.chatId}`, 'GET', { pathParams })\n      },\n\n      async update(\n        params: { chatId: string } & ChatsUpdateRequest,\n      ): Promise<ChatsUpdateResponse> {\n        const pathParams = { chatId: params.chatId }\n        const body = { name: params.name, privacy: params.privacy }\n        return fetcher(`/chats/${pathParams.chatId}`, 'PATCH', {\n          pathParams,\n          body,\n        })\n      },\n\n      async favorite(\n        params: { chatId: string } & ChatsFavoriteRequest,\n      ): Promise<ChatsFavoriteResponse> {\n        const pathParams = { chatId: params.chatId }\n        const body = { isFavorite: params.isFavorite }\n        return fetcher(`/chats/${pathParams.chatId}/favorite`, 'PUT', {\n          pathParams,\n          body,\n        })\n      },\n\n      async fork(\n        params: { chatId: string } & ChatsForkRequest,\n      ): Promise<ChatsForkResponse> {\n        const pathParams = { chatId: params.chatId }\n        const body = { versionId: params.versionId, privacy: params.privacy }\n        return fetcher(`/chats/${pathParams.chatId}/fork`, 'POST', {\n          pathParams,\n          body,\n        })\n      },\n\n      async findMessages(params: {\n        chatId: string\n        limit?: number\n        cursor?: string\n      }): Promise<ChatsFindMessagesResponse> {\n        const pathParams = { chatId: params.chatId }\n        const query = Object.fromEntries(\n          Object.entries({\n            limit:\n              params.limit !== undefined ? String(params.limit) : undefined,\n            cursor: params.cursor,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/chats/${pathParams.chatId}/messages`, 'GET', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n\n      async sendMessage(\n        params: { chatId: string } & ChatsSendMessageRequest,\n      ): Promise<ChatsSendMessageResponse | ChatsSendMessageStreamResponse> {\n        const pathParams = { chatId: params.chatId }\n        const body = {\n          message: params.message,\n          attachments: params.attachments,\n          system: params.system,\n          modelConfiguration: params.modelConfiguration,\n          responseMode: params.responseMode,\n        }\n\n        if (params.responseMode === 'experimental_stream') {\n          return await streamingFetcher(\n            `/chats/${pathParams.chatId}/messages`,\n            'POST',\n            { pathParams, body },\n          )\n        }\n\n        return fetcher(`/chats/${pathParams.chatId}/messages`, 'POST', {\n          pathParams,\n          body,\n        })\n      },\n\n      async getMessage(params: {\n        chatId: string\n        messageId: string\n      }): Promise<ChatsGetMessageResponse> {\n        const pathParams = {\n          chatId: params.chatId,\n          messageId: params.messageId,\n        }\n        return fetcher(\n          `/chats/${pathParams.chatId}/messages/${pathParams.messageId}`,\n          'GET',\n          { pathParams },\n        )\n      },\n\n      async findVersions(params: {\n        chatId: string\n        limit?: number\n        cursor?: string\n      }): Promise<ChatsFindVersionsResponse> {\n        const pathParams = { chatId: params.chatId }\n        const query = Object.fromEntries(\n          Object.entries({\n            limit:\n              params.limit !== undefined ? String(params.limit) : undefined,\n            cursor: params.cursor,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/chats/${pathParams.chatId}/versions`, 'GET', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n\n      async getVersion(params: {\n        chatId: string\n        versionId: string\n        includeDefaultFiles?: boolean\n      }): Promise<ChatsGetVersionResponse> {\n        const pathParams = {\n          chatId: params.chatId,\n          versionId: params.versionId,\n        }\n        const query = Object.fromEntries(\n          Object.entries({\n            includeDefaultFiles:\n              params.includeDefaultFiles !== undefined\n                ? String(params.includeDefaultFiles)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(\n          `/chats/${pathParams.chatId}/versions/${pathParams.versionId}`,\n          'GET',\n          { pathParams, ...(hasQuery ? { query } : {}) },\n        )\n      },\n\n      async updateVersion(\n        params: {\n          chatId: string\n          versionId: string\n        } & ChatsUpdateVersionRequest,\n      ): Promise<ChatsUpdateVersionResponse> {\n        const pathParams = {\n          chatId: params.chatId,\n          versionId: params.versionId,\n        }\n        const body = { files: params.files }\n        return fetcher(\n          `/chats/${pathParams.chatId}/versions/${pathParams.versionId}`,\n          'PATCH',\n          { pathParams, body },\n        )\n      },\n\n      async downloadVersion(params: {\n        chatId: string\n        versionId: string\n        format?: 'zip' | 'tarball'\n        includeDefaultFiles?: boolean\n      }): Promise<ArrayBuffer> {\n        const pathParams = {\n          chatId: params.chatId,\n          versionId: params.versionId,\n        }\n        const query = Object.fromEntries(\n          Object.entries({\n            format: params.format,\n            includeDefaultFiles:\n              params.includeDefaultFiles !== undefined\n                ? String(params.includeDefaultFiles)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(\n          `/chats/${pathParams.chatId}/versions/${pathParams.versionId}/download`,\n          'GET',\n          { pathParams, ...(hasQuery ? { query } : {}) },\n        )\n      },\n\n      async resume(params: {\n        chatId: string\n        messageId: string\n      }): Promise<ChatsResumeResponse> {\n        const pathParams = {\n          chatId: params.chatId,\n          messageId: params.messageId,\n        }\n        return fetcher(\n          `/chats/${pathParams.chatId}/messages/${pathParams.messageId}/resume`,\n          'POST',\n          { pathParams },\n        )\n      },\n    },\n\n    projects: {\n      async getByChatId(params: {\n        chatId: string\n      }): Promise<ProjectsGetByChatIdResponse> {\n        const pathParams = { chatId: params.chatId }\n        return fetcher(`/chats/${pathParams.chatId}/project`, 'GET', {\n          pathParams,\n        })\n      },\n\n      async find(): Promise<ProjectsFindResponse> {\n        return fetcher(`/projects`, 'GET', {})\n      },\n\n      async create(\n        params: ProjectsCreateRequest,\n      ): Promise<ProjectsCreateResponse> {\n        const body = {\n          name: params.name,\n          description: params.description,\n          icon: params.icon,\n          environmentVariables: params.environmentVariables,\n          instructions: params.instructions,\n          vercelProjectId: params.vercelProjectId,\n          privacy: params.privacy,\n        }\n        return fetcher(`/projects`, 'POST', { body })\n      },\n\n      async getById(params: {\n        projectId: string\n      }): Promise<ProjectsGetByIdResponse> {\n        const pathParams = { projectId: params.projectId }\n        return fetcher(`/projects/${pathParams.projectId}`, 'GET', {\n          pathParams,\n        })\n      },\n\n      async update(\n        params: { projectId: string } & ProjectsUpdateRequest,\n      ): Promise<ProjectsUpdateResponse> {\n        const pathParams = { projectId: params.projectId }\n        const body = {\n          name: params.name,\n          description: params.description,\n          instructions: params.instructions,\n          privacy: params.privacy,\n        }\n        return fetcher(`/projects/${pathParams.projectId}`, 'PATCH', {\n          pathParams,\n          body,\n        })\n      },\n\n      async delete(params: {\n        projectId: string\n        deleteAllChats?: boolean\n      }): Promise<ProjectsDeleteResponse> {\n        const pathParams = { projectId: params.projectId }\n        const query = Object.fromEntries(\n          Object.entries({\n            deleteAllChats:\n              params.deleteAllChats !== undefined\n                ? String(params.deleteAllChats)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/projects/${pathParams.projectId}`, 'DELETE', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n\n      async assign(\n        params: { projectId: string } & ProjectsAssignRequest,\n      ): Promise<ProjectsAssignResponse> {\n        const pathParams = { projectId: params.projectId }\n        const body = { chatId: params.chatId }\n        return fetcher(`/projects/${pathParams.projectId}/assign`, 'POST', {\n          pathParams,\n          body,\n        })\n      },\n\n      async findEnvVars(params: {\n        projectId: string\n        decrypted?: boolean\n      }): Promise<ProjectsFindEnvVarsResponse> {\n        const pathParams = { projectId: params.projectId }\n        const query = Object.fromEntries(\n          Object.entries({\n            decrypted:\n              params.decrypted !== undefined\n                ? String(params.decrypted)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/projects/${pathParams.projectId}/env-vars`, 'GET', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n\n      async createEnvVars(\n        params: {\n          projectId: string\n          decrypted?: boolean\n        } & ProjectsCreateEnvVarsRequest,\n      ): Promise<ProjectsCreateEnvVarsResponse> {\n        const pathParams = { projectId: params.projectId }\n        const query = Object.fromEntries(\n          Object.entries({\n            decrypted:\n              params.decrypted !== undefined\n                ? String(params.decrypted)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const body = {\n          environmentVariables: params.environmentVariables,\n          upsert: params.upsert,\n        }\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/projects/${pathParams.projectId}/env-vars`, 'POST', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n          body,\n        })\n      },\n\n      async updateEnvVars(\n        params: {\n          projectId: string\n          decrypted?: boolean\n        } & ProjectsUpdateEnvVarsRequest,\n      ): Promise<ProjectsUpdateEnvVarsResponse> {\n        const pathParams = { projectId: params.projectId }\n        const query = Object.fromEntries(\n          Object.entries({\n            decrypted:\n              params.decrypted !== undefined\n                ? String(params.decrypted)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const body = { environmentVariables: params.environmentVariables }\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/projects/${pathParams.projectId}/env-vars`, 'PATCH', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n          body,\n        })\n      },\n\n      async deleteEnvVars(\n        params: { projectId: string } & ProjectsDeleteEnvVarsRequest,\n      ): Promise<ProjectsDeleteEnvVarsResponse> {\n        const pathParams = { projectId: params.projectId }\n        const body = { environmentVariableIds: params.environmentVariableIds }\n        return fetcher(\n          `/projects/${pathParams.projectId}/env-vars/delete`,\n          'POST',\n          { pathParams, body },\n        )\n      },\n\n      async getEnvVar(params: {\n        projectId: string\n        environmentVariableId: string\n        decrypted?: boolean\n      }): Promise<ProjectsGetEnvVarResponse> {\n        const pathParams = {\n          projectId: params.projectId,\n          environmentVariableId: params.environmentVariableId,\n        }\n        const query = Object.fromEntries(\n          Object.entries({\n            decrypted:\n              params.decrypted !== undefined\n                ? String(params.decrypted)\n                : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(\n          `/projects/${pathParams.projectId}/env-vars/${pathParams.environmentVariableId}`,\n          'GET',\n          { pathParams, ...(hasQuery ? { query } : {}) },\n        )\n      },\n    },\n\n    deployments: {\n      async find(params: {\n        projectId: string\n        chatId: string\n        versionId: string\n      }): Promise<DeploymentsFindResponse> {\n        const query = Object.fromEntries(\n          Object.entries({\n            projectId: params.projectId,\n            chatId: params.chatId,\n            versionId: params.versionId,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        return fetcher(`/deployments`, 'GET', { query })\n      },\n\n      async create(\n        params: DeploymentsCreateRequest,\n      ): Promise<DeploymentsCreateResponse> {\n        const body = {\n          projectId: params.projectId,\n          chatId: params.chatId,\n          versionId: params.versionId,\n        }\n        return fetcher(`/deployments`, 'POST', { body })\n      },\n\n      async getById(params: {\n        deploymentId: string\n      }): Promise<DeploymentsGetByIdResponse> {\n        const pathParams = { deploymentId: params.deploymentId }\n        return fetcher(`/deployments/${pathParams.deploymentId}`, 'GET', {\n          pathParams,\n        })\n      },\n\n      async delete(params: {\n        deploymentId: string\n      }): Promise<DeploymentsDeleteResponse> {\n        const pathParams = { deploymentId: params.deploymentId }\n        return fetcher(`/deployments/${pathParams.deploymentId}`, 'DELETE', {\n          pathParams,\n        })\n      },\n\n      async findLogs(params: {\n        deploymentId: string\n        since?: number\n      }): Promise<DeploymentsFindLogsResponse> {\n        const pathParams = { deploymentId: params.deploymentId }\n        const query = Object.fromEntries(\n          Object.entries({\n            since:\n              params.since !== undefined ? String(params.since) : undefined,\n          }).filter(([_, value]) => value !== undefined),\n        ) as Record<string, string>\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/deployments/${pathParams.deploymentId}/logs`, 'GET', {\n          pathParams,\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n\n      async findErrors(params: {\n        deploymentId: string\n      }): Promise<DeploymentsFindErrorsResponse> {\n        const pathParams = { deploymentId: params.deploymentId }\n        return fetcher(\n          `/deployments/${pathParams.deploymentId}/errors`,\n          'GET',\n          { pathParams },\n        )\n      },\n    },\n\n    hooks: {\n      async find(): Promise<HooksFindResponse> {\n        return fetcher(`/hooks`, 'GET', {})\n      },\n\n      async create(params: HooksCreateRequest): Promise<HooksCreateResponse> {\n        const body = {\n          name: params.name,\n          events: params.events,\n          chatId: params.chatId,\n          url: params.url,\n        }\n        return fetcher(`/hooks`, 'POST', { body })\n      },\n\n      async getById(params: { hookId: string }): Promise<HooksGetByIdResponse> {\n        const pathParams = { hookId: params.hookId }\n        return fetcher(`/hooks/${pathParams.hookId}`, 'GET', { pathParams })\n      },\n\n      async update(\n        params: { hookId: string } & HooksUpdateRequest,\n      ): Promise<HooksUpdateResponse> {\n        const pathParams = { hookId: params.hookId }\n        const body = {\n          name: params.name,\n          events: params.events,\n          url: params.url,\n        }\n        return fetcher(`/hooks/${pathParams.hookId}`, 'PATCH', {\n          pathParams,\n          body,\n        })\n      },\n\n      async delete(params: { hookId: string }): Promise<HooksDeleteResponse> {\n        const pathParams = { hookId: params.hookId }\n        return fetcher(`/hooks/${pathParams.hookId}`, 'DELETE', { pathParams })\n      },\n    },\n\n    integrations: {\n      vercel: {\n        projects: {\n          async find(): Promise<IntegrationsVercelProjectsFindResponse> {\n            return fetcher(`/integrations/vercel/projects`, 'GET', {})\n          },\n\n          async create(\n            params: IntegrationsVercelProjectsCreateRequest,\n          ): Promise<IntegrationsVercelProjectsCreateResponse> {\n            const body = { projectId: params.projectId, name: params.name }\n            return fetcher(`/integrations/vercel/projects`, 'POST', { body })\n          },\n        },\n      },\n    },\n\n    rateLimits: {\n      async find(params?: { scope?: string }): Promise<RateLimitsFindResponse> {\n        const query = params\n          ? (Object.fromEntries(\n              Object.entries({\n                scope: params.scope,\n              }).filter(([_, value]) => value !== undefined),\n            ) as Record<string, string>)\n          : {}\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/rate-limits`, 'GET', {\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n    },\n\n    user: {\n      async get(): Promise<UserGetResponse> {\n        return fetcher(`/user`, 'GET', {})\n      },\n\n      async getBilling(params?: {\n        scope?: string\n      }): Promise<UserGetBillingResponse> {\n        const query = params\n          ? (Object.fromEntries(\n              Object.entries({\n                scope: params.scope,\n              }).filter(([_, value]) => value !== undefined),\n            ) as Record<string, string>)\n          : {}\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/user/billing`, 'GET', {\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n\n      async getPlan(): Promise<UserGetPlanResponse> {\n        return fetcher(`/user/plan`, 'GET', {})\n      },\n\n      async getScopes(): Promise<UserGetScopesResponse> {\n        return fetcher(`/user/scopes`, 'GET', {})\n      },\n    },\n\n    reports: {\n      async getUsage(params?: {\n        startDate?: string\n        endDate?: string\n        chatId?: string\n        messageId?: string\n        userId?: string\n        limit?: number\n        cursor?: string\n      }): Promise<ReportsGetUsageResponse> {\n        const query = params\n          ? (Object.fromEntries(\n              Object.entries({\n                startDate: params.startDate,\n                endDate: params.endDate,\n                chatId: params.chatId,\n                messageId: params.messageId,\n                userId: params.userId,\n                limit:\n                  params.limit !== undefined ? String(params.limit) : undefined,\n                cursor: params.cursor,\n              }).filter(([_, value]) => value !== undefined),\n            ) as Record<string, string>)\n          : {}\n        const hasQuery = Object.keys(query).length > 0\n        return fetcher(`/reports/usage`, 'GET', {\n          ...(hasQuery ? { query } : {}),\n        })\n      },\n    },\n  }\n}\n\n// Default client for backward compatibility\nexport const v0 = createClient()\n"],"names":[],"mappings":"AAUO;AACP;AACA;AACA;AACO;;ACbA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;"}